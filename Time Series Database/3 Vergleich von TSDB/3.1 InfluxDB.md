# 3.1 InfluxDB
In diesem Abschnitt wird die TSDB *InfluxDB* vorgestellt sowie dessen Vor- und Nachteile gegenübergestellt.
InfluxDB wurde im Jahr 2013 entwickelt und ist mittlerweile eine der am weitesten verbreitete TSDB. InfluxDB ist eine NOSQL-TSDB und eine Open-Source-Datenbank.
Neben der Open-Source-Version ist InfluxDB auch als cloudbasierte Datenbank und Enterprise-Version erhältlich.
InfluxDB wurde speziell für die Verarbeitung von riesigen Mengen an zeitindizierten Daten, die zum Beispiel von IoT-Geräten erzeugt werden, entwickelt.  
Die Grundidee von InfluxDB ist das Speichern von Zeitreihen sowie insbesondere die Verfolgung von Metriken und Ereignissen von Geräten und Diensten im Zeitverlauf.
InfluxDB unterstützt hohe Schreiblasten, speichert große Datenmengen und spart Platz (und beschleunigt Abfragen) durch Downsampling nicht relevanter Werte, automatisches Auslaufen und Löschen unerwünschter Daten sowie Backup und Restore. Neben der Anwendung als TSDB kann InfluxDB auch als *Spatial DBMS* funktionieren, dessen Funktionsweise wird hier allerdings nicht betrachtet [3.1.1].

## Datenmodell/-struktur

Die Strukturierung der Daten erfolgt mit Elementen wie *timestamps*, *field keys*, *field values* oder *tags*.
Für die *timestamps* (Zeitstempel) werden als Spalte *_time* die Daten mit einem Zeitstempel indexiert. Die Auflösung der Zeitstempel ist variabel und kann bis zu einer Nanosekunde dauern.

Damit eine effiziente Speicherung der unterschiedlichen Zeitreihenserien erfolgt, werden die Datenelemente in Dateien als zeitstrukturierten Merge-Tree- (engl: Time-Structured Merge Tree, kurz: TSM) und Zeitreihenindex- (engl: Time-Structured Index, kurz: TSI) hinterlegt. Eine TSM-Datei besteht aus den in Abbildung 3.1.1 dargestellten vier Abschnitten [3.1.2]. 

![Struktur TSM](../images/aufbau_tsm_file.png) 
Abbildung 3.1.1: Struktur von TSM [3.1.2]

Damit wird erreicht, dass die Anzahl der Datenbankenserien nicht durch den Speicherplatz auf der Serverhardware begrenzt ist. Das Prinzip dieser Speicherverteilung wird im weiteren Verlauf dieses Kapitels<!-- "Abschnitt" ?-->genauer erläutert. 
Zur Anzeige von Rohdaten im Daten Explorer <!-- koppeln -->und zur Rückgabe von Abfrageergebnisse kann zudem ein tabellarisches Datenschema in kommentierter CSV-Syntax verwendet werden [3.1.2].   


Das tabellarische Datenschema beinhaltet 
1.  Kommentarzeilen, um Eigenschaften der Spalte zu beschreiben (z.B.<!-- "zum Beispiel" --> durch #group, #datatype, #default)
2.  Eine Kopfzeile, um die Spaltenbeschriftungen, die die Daten in jeder Spalte beschreibt, zu definieren (z.B. mit table, _value, _field, _measurement) <!-- vllt. besser: "... Spaltenbeschriftungen zu definieren, welche die Daten in jeder Spalte beschreiben"; Achtung: Mehrzahl "beschreiben" -->
3.  Datenzeile<!-- wenn Einzahl dann "eine Datenzeile" oder Mehrzahl -->, die in der Kopfzeile angegebenen Daten für einen Punkt enthalten
4.  Zusätzlich zu den Spalten, die in jeder Datenzeile (die in der Kopfzeile angegeben sind) sind die Spalten {annotation, result, table} optional <!-- soll das vllt. so heißen: "optionale Spalten {annotation, result, table}, zusätzlich zu den Spalten, die in jeder Datenzeile sind"; ich verstehe den Aufzählungspunkt hier nicht -->
5.  Gruppenschlüssel, um die Datensätze zu gruppieren, die in bestimmten Spalten gemeinsame Werte aufweisen, um den Inhalt von Ausgabetabellen zu bestimmen. 

Außerdem verfügt InfluxDB über zwei interne SQL-ähnliche Abfragesprachen: InfluxQL und Flux.<!-- Doppelpunkt eingefügt -->
Durch die eigenen Sprachen gibt es viele vorimplementierte Funktionen, die genau auf die Abfragen in der DB ausgerichtet sind.  <!-- vllt. besser: "die für die Abfragen in der DB optimiert sind" -->
InfluxDB unterstützt die Datentypen Integer, Float, String und Boolean [3.1.2].

## Partitionierungsmechanismen<!-- geändert in Partitionierung, statt Partionierung-->

Für die Partitionierung <!-- geändert in Partitionierung, statt Partionierung-->der Daten wird die *Sharding Methode*<!--koppeln--> verwendet. Ein Datensatz wird in mehrere Untergruppen, den sogenannten *Shards* aufgeteilt und jeweils von einer eigenen Serverinstanz verwaltet.  
Die Aufteilung der Daten kann z.B.<!-- "zum Beispiel" --> nach bestimmten Indexen einer Spalte<!-- "Spalten-Indexes" --> erfolgen. Bei InfluxDB erfolgt die Aufteilung nach zeitlichen Datenblöcken und wird auf der InfluxDB Speicher Engine<!--koppeln-->, der TSM (engl. Time-Structured Merge Tree), der Storage Engine Datenbank<!--koppeln--> von InfluxDB abgebildet.  
In den TSM-Dateien sind die kodierten und komprimierten Zeitreihendaten, die in Shards organisiert sind, enthalten.  
Jedes Shard wird zu einer bestimmten Shardsgruppe<!-- "Shardgruppe" oder "Shard-Gruppe"--> zugeordnet.  <!-- hier würde ich keinen Zeilenumbruch setzen-->
Shardsgruppen<!-- "Shardgruppen"--> sind Container für Shards, in denen die eigentlichen Zeitreihendaten enthalten sind. Die Zeitintervalle der Shards fallen in das Zeitintervall der Shardsgruppe.  
Pro Shardsgruppe kann es entweder nur einen einzigen Shard geben (z.B. in der Open-Source Version<!-- koppeln --> von InfluxDB) oder mehrere Shards pro Gruppe, was z.B.<!-- zum Beispiel--> häufiger in einem Multi-Node-Cluster vorkommt.  
Jede Shardsgruppe<!-- "Shardgruppe"--> besitzen<!-- "besitzt"--> ihre eigenen Aufbewahrungsrichtlinien, denen die Shards der Gruppe unterliegen.
Ein Bestandteil dieser Richtlinien ist z.B.<!-- zum Beispiel--> die Gruppendauer der Shards. Diese gibt das Zeitfenster vor, das jede Shardsgruppe<!-- "Shardgruppe"--> umfasst.  
Bei der Konfiguration der Aufbewahrungsrichtlinie kann das Zeitintervall entsprechend angegeben werden. Standardmäßig beträgt dies sieben Tage.  
Das Sharding der Daten in InfluxDB ermöglicht eine Steigerung der Gesamtleistung.  
Dabei sollte auch bedacht werden, dass die Daten in TSDB immer weiter zunehmen und eine Unterteilung der Daten dafür sorgt, die Effizienz der Datenbank durch den steigenden Datengehalt<!-- vllt. besser: "durch das steigende Datenvolumen" ?--> nicht negativ zu beeinflussen, da eine detaillierte<!-- anderes Wort vllt. besser?--> Aufteilung der Datensätze erfolgen kann [3.1.3].   

## Replikationsmechanismen
Es gibt keine Vorschrift, nach was für einem<!-- "nach welchem"--> Mechanismus und<!-- löschen--> wie viele Kopien der Daten erstellt werden können.   
Der Replikationsmechanismus ist demnach frei wählbar. Der Replikationsfaktor kann in den Datenbank Aufbewahrungsrichtlinien<!-- koppeln--> angegeben werden. Es ist allerdings zu beachten, dass es nicht möglich ist, zwei Kopien der gleichen Daten in einer gemeinsamen Shard-Gruppe<!-- hier andere Schreibweise? gekoppelt; vgl. oben--> zu speichern.   
Im Idealfall befinden sich diese in separaten Shard-Gruppen und auf<!-- in oder auf? --> separaten Knoten. Dadurch ist gewährleistet, dass bei einem Ausfall eines Knotens immer noch eine Kopie auf einem anderen Knoten zur Verfügung steht. [3.1.3]

## Unterstützte Programmiersprachen
InfluxDB wurde in Go implementiert. Folgende weitere Programmiersprachen werden unterstützt [3.1.1]:

- .Net
- Clojure
- Erlang
- Haskell
- Java
- JavaScript
- JavaScript (Node.js)
- Lisp
- Perl
- PHP
- Python
- R
- Ruby
- Rust
- Scala

## APIs und andere Konzeptzugriffe
Die Zeitreihendaten werden über eine HTTPS API Schnittstelle<!--gekoppelt--> geliefert und auch<!-- evt. löschen?--> neue Dateneingaben können über dieselbe Schnittstelle akzeptiert werden.
Dadurch bietet InfluxDB eine einfache Möglichkeit der Interaktion mit der Datenbank. Es werden<!-- "Für" statt "Es werden" --> HTTP-Antwortcodes, HTTP-Authentifizierung, JWT-Tokens und Basisauthentifizierung sowie Antworten in<!-- "wird" statt "in" --> JSON verwendet [3.1.1].


## Einsatzbereiche
In Bereichen, in denen Zeitreihendaten generiert werden, die sehr komplex sind und die Kapazitäten herkömmlicher Datenbanken übersteigen (z.B. auch durch das Vorliegen von halbstrukturierten Daten), ist die Anwendung von InfluxDB sinnvoll.  <!-- hier den ganzen Satz umstellen: "Die Anwendung von InfluxDB ist sinnvoll in Bereichen, in denen [...] übersteigen ([...]).-->
Grundsätzlich ist InfluxDB auf jegliche Art von zeitbasierten Messungen, Speicherung und Abfrage in Bereichen wie Betriebsüberwachung, Anwendungsmetriken, Messungen von IoT-Geräten und Echtzeitanalysen spezialisiert [3.1.1].

Als Anwendungsbeispiel kann z.B.<!-- löschen--> die Entwicklung eines neuen IoT-Produkts für intelligente Thermostate dienen. Die IoT-Sensoren messen in regelmäßigen Abständen die Temperatur, die in einer InfluxDB Datenbank<!-- koppeln--> gespeichert werden.  <!-- Zeilenumbruch entfernen?-->
Zusätzlich können Benutzer die Temperatur des intelligenten Thermostats über die Anwendung einstellen. Jedes Mal, wenn der Benutzer das Thermostat ändert, aktualisiert sich der Zustand des Thermostats in einer zusätzlichen klassischen Datenbank.  <!-- Zeilenumbruch entfernen?-->
Außerdem wird eine Historie aller Thermostat-Temperatureinstellungen zusammen mit den Temperaturmessungen aufbewahrt.  
Die Temperatureinstellungen und -messungen ermöglichen, das Benutzerverhalten zu analysieren.   <!-- vllt. besser: "... ermöglichen die Analyse des Benutzerverhaltens."-->
Außerdem<!-- löschen und Teilsatz umstellen--> können diese Daten dazu dienen, das intelligente<!--"smarte"--> Thermostat noch intelligenter zu machen, indem Änderungen vorhergesagt werden können, bevor der Benutzer die Einstellungen überhaupt geändert hat [3.1.5].<!-- Vorhersage als Empfehlung?-->

## Vorteile, Besonderheiten und Nachteile <!-- hier würde ich vllt. nochmal in einzelne Zwischenüberschriften unterteilen, vgl. GridDB-->
InfluxDB verfügt über viele leistungsstarke Funktionen und ist nicht ohne Grund einer der beliebtesten TSDBs (siehe oben)<!-- "... ist unter anderem wegen der oben genannten Gründe eine der beliebtesten TSDBs"; Achtung: "eine"-->. Die Anpassungsfähigkeit und der flexible Einsatz stellt eine dieser Besonderheiten dar. Dazu gehört zum Beispiel die Schemafreiheit.
Als NoSQL Datenbank<!--koppeln--> verfolgt InfluxDB kein bestimmtes Datenschema.   <!-- Zeilenumbruch entfernen?-->
Es kann sowohl<!--"sowohl" löschen wg. doppeltem "als" später--> als relationale Datenbank über den CSV Syntax<!-- "über die CSV-Syntax"--> als auch<!-- "und" statt "als auch"--> als nicht relationale Datenbank in Zuge der TSI und TSM eingesetzt werden. Zudem können durch die Schemafreiheit auch schwächer strukturierte Daten ohne einheitliche Struktur abgespeichert werden. Allerdings ist hier anzumerken, dass durch die Schemafreiheit auf die Prüfung der Daten im DBMS verzichtet wird [3.1.6]. 

Die Leistungsstärke beim Umgang mit großen Datensätzen sowie die hohe Skalierbarkeit kommen durch die Anwendung des Shardings zustande.  
Wie zuvor erwähnt, wird dadurch sichergestellt, dass durch das Aufteilen große Datensätze gespeichert und verarbeitet werden können.  <!-- mit Satz davor verbinden, doppelte Aussage mit "großen Datensätzen"-->
Mithilfe dieser Methode können Datenmengen verwaltet werden, die normalerweise die Kapazität eines einzelnen Servers sprengen<!-- vllt. besser: "übersteigen"--> würden.  
Dabei hat die Anzahl der gespeicherten TSM keinen Einfluss auf die Startzeit der Datenbank<!-- Startzeit der Datenbank? vllt. genauer-->, da die einzelnen Teile je von<!-- "von je" tauschen--> einer eigenen Serverinstanz verwaltet werden.  
Dadurch werden nicht nur die Daten selbst, sondern auch die dafür benötigte Rechenleistung aufgeteilt. 
<!-- hier vllt. Zwischenüberschrift einfügen--> Grundsätzlich ist ein Nachteil bei<"-- "beim"--> Sharding, dass es umständlich sein kann, bei bereits festgelegten Untergruppen weitere Server hinzuzufügen, da dies sehr umfangreiches Umspeichern auf den Servern erfordert.   
Die Untergruppen bzw. TSM werden in InfluxDB durch ihr<!-- "ihre"--> Zeitfenster definiert. Das Hinzufügen weiterer Untergruppen stellt daher keine Schwierigkeit dar, da das Zeitfenster mit der Zeit einfach weiter wächst.  
Allerdings können die flexiblen Aufbewahrungsrichtlinien (siehe Partitionierungsmechanismus) Hindernisse mit sich bringen.  
Da die Abfrage primär über bestimmte Zeitintervalle erfolgt, stellt auch die Schwierigkeit der Abfrage über Joins beim Sharding oder andere Kriterien als das Aufteilungskriterium kein Problem dar, da durch die Abfrage die Zeitintervalle der Untergruppen direkt abgefragt werden.  <!-- durch die Aufteilung in zwei Sätze wird es klarer-->
Grundsätzlich werden in NoSQL-Systemen Joins nur<!-- "nur" löschen--> kaum unterstützt. Deswegen kann das Sharding für NoSQL-Systeme wie InfluxDB ohne weitere Probleme implementiert werden [3.1.4].  

Ein weiterer Vorteil ist, dass die Abfragesprachen speziell für InfluxDB entwickelt wurden und dadurch auf die Abfrage von Zeitreihendaten ausgelegt sind. Die Ähnlichkeit zur gängigen SQL-Abfragesprache sorgt außerdem dafür, dass Abfragen leicht durchgeführt werden können.
Auch wenn die internen Abfragesprachen große Ähnlichkeiten mit SQL aufweisen, muss sich dennoch an eine neue Sprache gewöhnt werden. 

Desweiteren kann die Datenreduktion als vorteilhaft angesehen werden.  
Der primäre Anwendungsfall von InfluxDB besteht darin, dass die Daten in jedem beliebigen Intervall oder mit beliebiger Geschwindigkeit eingegeben werden können, unabhängig vom Datenvolumen. Die Art und Weise dieser Abfragung<!-- "Abfrage"--> ist die Reduzierung der Daten auf der Grundlage der Eingabedaten [3.1.7].

Durch die starke Spezialisierung als TSDB ist InfluxDB auf die Zeitindexierung angewiesen. Eine gute Performance der Abfragen und Verarbeitungen kann somit nur gewährleistet werden, wenn die zeitliche Abfolge stimmt. 
Durch ihren Aufbau ist sie nur bedingt für das Speichern von anderen, nicht-zeitbezogenen Werten geeignet.

Zuletzt sollte der Einsatz als Open-Source-Single-Server-Version und die Konzeption für die Anwendung in Docker und der Cloud angemerkt werden [3.1.8], <!-- ab hier als weiterer Satz--> wobei dadurch, dass InfluxDB auch über eine Enterprise Version<!--koppeln--> verfügt, die Open-Source-Version in gewissen Bereichen eingeschränkt ist.

<!-- Vor- und Nachteile klar voneinander abgrenzen-->
<!-- Gibt es Besonderheiten? -->
